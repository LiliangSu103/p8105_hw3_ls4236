---
title: "p8105_hw3_ls4236"
author: "Liliang Su"
date: "2025-10-04"
output: github_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(p8105.datasets)
library(patchwork)
library(ggridges)

knitr::opts_chunk$set(
  fig.width = 8,
  fig.asp = .6,
  out.width = "90%"
)

theme_set(theme_minimal() + theme(legend.position = "bottom"))

options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)

scale_colour_discrete = scale_colour_viridis_d
scale_fill_discrete = scale_fill_viridis_d
```

## Problem 1

Load the data

```{r}
data("instacart")
```

### Dataset Exploration and description

Firstly explore the data and check missing values.

```{r}
str(instacart)
sum(is.na(instacart))
```

Here is a brief description about `instacart` dataset:

- **Structure**: The dataset contains `r nrow(instacart)` observations (rows) and `r ncol(instacart)` dimentions (columns), with no missing data. Each row represents a single product added to a customer's grocery cart, while each column specifies certain information about the order.
- **Key variables**: 
  - `order_id`, `user_id`: Unique identifier for orders and users.
  - `product_id`, `product_name`: Identify the ordered item and its name.
  - `reorder`: Whether the user had placed orders containing this product before.
  - `order_dow`, `order_hour_of_day`: Day of a week and specific hour the order was placed.
  - `department`, `department_id`, `aisle`, `aisle_id`: Specific aisle and department (along with their IDs) the product belongs to.
- **Illustrative examples**:
  - One observation from the dataset details a customer (User #112108) who placed their 4th order on a Thursday at 10:00 AM, starting their shopping with Bulgarian Yogurt, which is located at Yogurt aisle, Dairy & Eggs department. This item was listed as reordered, indicating the customer had purchased it before, which reflects a habitual buying pattern for this everyday dairy product. The order occurred just 9 days after their previous one, suggesting a relatively frequent and consistent shopping rhythm. This example illustrates how the dataset captures routine purchasing behavior for staple grocery items.

### Answers for questions

```{r}
byaisle_df = instacart |> 
  group_by(aisle) |> 
  summarise(n = n()) |> 
  arrange(desc(n))
```

1. There are in total `r byaisle_df |> nrow()` aisles in the dataset, and the `r byaisle_df[1,1]` aisle are the most items ordered from.

2. The required graph is shown below, which is a bar plot with aisle_id on the x-axis and the number of items on the y-axis.

```{r}
instacart |> 
  group_by(aisle_id) |> 
  summarise(n = n()) |> 
  filter(n > 10000) |> 
  ggplot(aes(x = reorder(aisle_id, n), y = n)) +
  geom_col() +
  labs(title = "Number of Items Ordered by Aisle (>10,000)", 
       x = "Aisle ID", 
       y = "Number of Items") +
  theme(
    axis.text.x = element_text(size = 8)
  )
  
```

3. The required table is shown below.

```{r}
instacart |> 
  filter(aisle %in% c("baking ingredients", "dog food care", "packaged vegetables fruits")) |>
  group_by(aisle, product_name) |> 
  summarise(n = n(), .groups = "drop_last") |> 
  arrange(aisle, desc(n)) |> 
  mutate(n_rank = min_rank(desc(n))) |> 
  filter(n_rank < 4) |> 
  select(-n_rank) |> 
#  slice_max(order_by = n, n = 3) |> # alternative way
  knitr::kable(digits = 2)

```

4. The required table is shown below.

```{r}
instacart |> 
  filter(product_name %in% c("Pink Lady Apples", "Coffee Ice Cream")) |> 
  group_by(product_name, order_dow) |> 
  summarise(mean_hour = mean(order_hour_of_day), .groups = "drop_last") |>
  arrange(product_name, order_dow) |> 
  pivot_wider(
    names_from = order_dow,
    values_from = mean_hour
  ) |> 
  knitr::kable(digits = 2)

```

## Problem 2

### Import and tidy

Firstly, import and clean the `Zip Codes` dataset.

```{r}
zip_df = 
  read_csv(file = "./data/Zip Codes.csv", na = c("NA",".","")) |> 
  janitor::clean_names() |> 
  select(-file_date, -state_fips) |> # file_date and state.fip are the same for every observations, which are redundant
  mutate(
    county_fips = as.character(county_fips),
    zip_code = as.character(zip_code)
  ) |> 
  rename(county_zip = county) # rename to differentiate bewteen both datasets
  
```

Secondly, import and clean the `Zillow Rental Price` dataset.

```{r}
zillow_df = 
  read_csv(file = "./data/Zip_zori_uc_sfrcondomfr_sm_month_NYC.csv", na = c("NA",".","")) |> 
  janitor::clean_names() |> 
  select(-region_type, -state, -state_name, -city, -metro) |> # state, state_name, region_type, metro, and city are redundant as they have the same value for every observations
  rename(zip_code = region_name, county_zillow = county_name, region_id_zillow = region_id) |> # rename to differentiate bewteen both datasets
  pivot_longer(
    cols = x2015_01_31:x2024_08_31,
    names_prefix = "x",
    names_to = "date",
    values_to = "zori"
  ) |> # tidy up the date and zori variables
  separate(
    date,
    into = c("year", "month", "day"),
    sep = "_"
  ) |> 
  relocate(year, month, day) |> 
  mutate(
    size_rank = as.integer(size_rank),
    region_id_zillow = as.character(region_id_zillow),
    zip_code = as.character(zip_code),
    year = as.integer(year),
    month = as.integer(month),
    day = as.integer(day),
    county_zillow = str_remove_all(county_zillow, " County") # remove the character "county" for all observations in the column "county_zillow"
  ) |> 
  filter(!is.na(zori)) |>  # zori is the main variable of interest, hence any row without a value can’t contribute to the analysis
  rename(borough = county_zillow) |> 
  mutate(borough = factor(recode(borough,
                          "New York" = "Manhattan",
                          "Kings" = "Brooklyn",
                          "Queens" = "Queens",
                          "Bronx" = "Bronx",
                          "Richmond" = "Staten Island"), levels = c("Manhattan", "Brooklyn", "Queens", "Staten Island", "Bronx"))
         )

```

### Analysis


```{r}
# Count the number of months each ZIP code appears
zip_counts = zillow_df |> 
  group_by(zip_code) |> 
  summarise(n_months = n())

# How many ZIP codes appear in all 116 months
zip_116 = zip_counts |> 
  filter(n_months == 116) |> 
  nrow()

# How many ZIP codes appear fewer than 10 times
zip_less_10 = zip_counts |>
  filter(n_months < 10) |> 
  nrow()

```

- There are `r zip_116` ZIP codes observed 116 times.

- There are `r zip_less_10` ZIP codes observed fewer than 10 times

- Those always observed ZIP codes usually correspond to major metropolitan areas where Zillow would keep track of rental price every month consistently; while rarely observed ZIP codes normally correspond to rural or less populated areas, or areas with rare rental activity, so Zillow didn’t report data for every month.


### Average rent table

```{r}
# Average rental price by borough and year
zillow_boro_n_yr = zillow_df |> 
  group_by(borough, year) |> 
  summarise(avg_price = mean(zori, na.rm = TRUE), .groups = "drop")

zillow_boro_n_yr |> 
  pivot_wider(
    names_from = year,
    values_from = avg_price
  ) |> 
  knitr::kable(digits = 2)
  
```

The above table shows the average rental price in each borough.

- Over the 10 years, the zori index has increased rapidly across all 5 boroughs in NYC, reflecting a rising rents trend.

- Manhattan most of the time has ranked first by average rent prices, while Brown remains the lowest.

- Some boroughs like Brooklyn and Manhattan experienced sharper increases in 2022, indicating a rental boom.

### Plotting

```{r}
zillow_line = zillow_boro_n_yr |> 
  ggplot(aes(x = year, y = avg_price, color = borough)) +
  geom_point(aes(shape = borough)) +
  geom_smooth(method = "loess", formula = "y ~ x", se = FALSE) +
  labs(
    title = "NYC Rent Prices Trend",
    x = "Year",
    y = "Yearly Average Rent"
  ) +
  theme(legend.position = "right")


# box plot
zillow_box = zillow_df |> 
  group_by(zip_code, borough, year) |> 
  summarise(avg_price = mean(zori, na.rm = TRUE), .groups = "drop") |>
  ggplot(aes(x = factor(year), y = avg_price)) + 
  geom_boxplot(aes(fill = borough), outlier.shape = NA, alpha = 0.5) +  
  # each jitter point represents the yearly average rent within a certain ZIP code
  geom_jitter(aes(color = borough), width = 0, alpha = 0.3) +
  facet_grid(borough ~. , scales = "free_y") +
  theme(axis.text.x = element_text(size = 8),
        axis.text.y = element_text(size = 8)) +
  scale_x_discrete(
    labels = c("2015","","2017","","2019","","2021","", "2023", "")
  ) +
  labs(
    title = "NYC Rent within ZIP codes",
    x = "Year",
    y = "Yearly Average Rent"
  ) +
  theme(legend.position = "none")

(zillow_line | zillow_box)

```

Overall, the above plot shows clear temporal differences within in ZIP codes for all available years.

- **Upward trend**: Across all boroughs, average rents show a general upward trend over the decade, with a significant increase in 2022, which is probably due to post-pandemic recovery in rental market.

- **Borough difference**: Manhattan maintains the highest rents throughout the period, while the Bronx and Staten Island remain the most affordable, and Brooklyn and Queens steadily show steady increase over time.

- **Variation within ZIP codes**: The spread of rents (IQR) within boroughs all widens in second half of the period, implying growing inequality between neighborhoods. In addition, several ZIP codes within Manhattan and Queens have very high outliers, which could be explained by luxury rental market.

- **Borough stability**: Queens and Staten Island show relatively narrow boxes and short whisker, suggesting more stable rent levels; while Brooklyn and Manhattan show larger spreads and longer whisker, indicating greater neighborhood-level and monthly variability.

```{r}
zillow_mon_2023 = zillow_df |> 
  filter(year == 2023) |> 
  group_by(borough, zip_code, month) |> 
  summarise(avg_price = mean(zori, na.rm = TRUE), .groups = "drop") |> 
  ggplot(aes(x = avg_price, y = borough, fill = borough)) +
  geom_density_ridges(alpha = 0.5, scale = .8, color = "black") +
  labs(
    title = "Ridge Density plot of ZIP-code-level rent across boroughs in 2023",
    x = "Monthly Average Rent",
    y = "Borough"
  ) +
  theme(legend.position = "none")

zillow_mon_2023
```

Overall, the ridge plot illustrates the persistent spatial inequality in rental price distributions across NYC boroughs in 2023.

- Manhattan clearly has the highest average ZIP-level rents, centered in the upper range (above 4,000), with a relatively wide spread, indicating the inequality between neighborhoods.

- Brooklyn and Queens, especially Brooklyn, share a similar distribution with Manhattan, with narrower distributions and values concentrated in the middle range (below 3,000), reflecting diverse neighborhoods with both mid- and high-range rents.

- Bronx and Staten Island display lower average rents (below 2500), with tighter distributions around more affordable houses.

### Combine

```{r}
combined_plot = zillow_box + zillow_mon_2023

ggsave("./results/borough_rental_distribution.png",
       plot = combined_plot,
       width = 12, height = 6, dpi = 300)
```

## Problem 3

### Import and tidy

Import, merge, and clean both datasets.

```{r}

nhanes_accel = read_csv("./data/nhanes_accel.csv" , na = c("NA",".","")) |> 
  janitor::clean_names()
  
nhanes_demo = read_csv("./data/nhanes_covar.csv", skip = 4 , na = c("NA",".","")) |> 
  janitor::clean_names()
  
nhanes_df = nhanes_demo |> 
  inner_join(nhanes_accel, by = "seqn") |>  # merge dataset
  filter(age >= 21, !is.na(sex), !is.na(age), !is.na(bmi), !is.na(education)) |> # filter participants
  mutate(
    sex = factor(sex, 
                 levels = c(1,2), 
                 labels = c("Male", "Female")),
    education = factor(education, levels = c(1,2,3),
                       labels = c("Less than high school", "High school equivalent", "More than high school"),
                       ordered = TRUE)
  ) |> # convert to factors
  pivot_longer(
    cols = starts_with("min"),
    names_to = "minute",
    values_to = "mims"
  )
```

### Table and visualization

```{r}
nhanes_df |> 
  group_by(education, sex) |> 
  summarise(n = n_distinct(seqn), .groups = "drop") |> 
  pivot_wider(
    names_from = sex,
    values_from = n
  ) |> 
  knitr::kable(digits = 2)
```

- The above table shows that there are 12 more men than women in the high school or equivalent group, whereas in the other two education groups, the numbers of men and women are fairly comparable.

```{r}
nhanes_df |> 
  ggplot(aes(x = age, fill = sex)) +
  geom_density(alpha = 0.5, ) +
  facet_grid(education ~ .) +
  labs(
    title = "Age Distributions of Men and Women by Education Category",
    x = "Age (years)",
    y = "Density",
    fill = "Sex"
  )
```

- The plot shows that age distributions differ by education groups. Participants with higher education levels tend to be younger on average for both men and women, which contrasts with with the pattern observed in the group with less than a high school education. 

- Other than the high school equivalent education group, the age distributions for men and women are similar and have large overlapping area, suggesting no strong gender differences in age for this sample.

### Tranditional analyses

```{r}
# Aggregate across minutes
nhanes_total = nhanes_df |> 
  group_by(seqn, age, sex, bmi, education) |> 
  summarise(
    total_activity = sum(mims), .groups = "drop"
  )

nhanes_total |> 
  ggplot(aes(x = age, y = total_activity, color = sex)) +
  geom_point(aes(shape = sex), alpha = .6) +
  geom_smooth(method = "loess", formula = "y ~ x", se = FALSE) +
  facet_grid(. ~ education) +
  labs(
    title = "Total activities vs. age across education groups",
    x = "Age",
    y = "Total activities"
  ) 
```


- The plot shows that total daily activity tends to decline significantly with age across all education groups, with younger participants generally having higher total MIMS values. 

- Across education levels, participants with higher education levels tend to maintain their activity longer, showing a slower decline compared to those with less education.

- In terms of gender differences, women appear to have slightly lower or more variable activity levels compared to men, especially in higher education groups.

### 24-hour activity time courses

```{r}
# Create new column time
nhanes_hour = nhanes_df |> 
  mutate(hour = as.numeric(str_remove_all(minute, "min")) %/% 60) |> 
  group_by(education, sex, hour) |> 
  summarise(
    avg_activity = mean(mims), # the average mims across certain gender at certain time in a certain group.
    .groups = "drop"
  )

nhanes_hour |> 
  ggplot(aes(x = hour, y = avg_activity, color = sex)) +
  geom_point(alpha = .6) +
  geom_smooth(se = FALSE, method = "loess", formula = "y~x") +
  facet_grid(. ~ education) +
  labs(
    title = "24-Hour Activity Courses by Education and Sex",
    x = "Hour of Day",
    y = "Average MIMS",
    color = "Sex"
  )
```

**Pattern & Conclusion**:

- Activity peaks in the daytime hours (around 8 a.m. to 6 p.m.) and declines sharply at night, which is consistent with daily human activity cycles.

- Across all education levels, men tend to have slightly higher activity levels than women in daytime.

- The gender gap in activity levels appears to expand during daytime as the increase of the participant's education level, possibly reflecting the difference in job types affected by gender.

- Participants with lower education levels, especially male, have higher activity levels in daytime hours, potentially reflecting the difference in occupation types associated with educational background.



